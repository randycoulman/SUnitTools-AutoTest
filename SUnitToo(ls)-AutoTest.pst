<?xml version="1.0"?><st-source><!-- Name: SUnitToo(ls)-AutoTestNotice: The MIT LicenseCopyright (c) 2012-2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: # SUnitToo(ls)-AutoTestAutomatically run appropriate tests when a method changes in Cincom Visualworks Smalltalk.SUnitToo(ls)-AutoTest is licensed under the MIT license.  See the Copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.SUnitToo(ls)-AutoTest's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/SUnitTools-AutoTest).SUnitToo(ls)-AutoTest was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# IntroductionSUnitToo(ls)-AutoTest automatically runs relevant SUnitToo tests when a method is changed.  The tests to run are selected using the same approach as the standard SUnitToo(ls) use.  If a test method is changed, then that method will be run.  If a non-test method in a TestCase subclass is changed, then all of the tests in that class will be run.  If a method in a non-TestCase subclass is changed, then all of the tests in the associated TestCase subclass (if any) will be run.SUnitToo(ls)-AutoTest keeps track of a "hit count" for the changed method.  That is, how many times the method was executed while running the associated tests.  This allows you to see at a glance whether the method you just changed is covered by the relevant tests.# UsageBy default, SUnitToo(ls)-AutoTest is inactive when loaded into an image.  In order to activate it, one or more AutoTest UIs must be active.  SUnitToo(ls)-AutoTest currently has two UIs available:* The main AutoTestUI:  This UI runs in a separate window.  It can be opened by selecting `Tools` -> `AutoTest UI` in the Launcher.  This window displays the status of running or completed tests, as well as the hit count for the last changed method.  In addition, it allows you to cancel the current test run.  If any tests fail or raise errors, you can click on the test status portion of the window to browse the failing tests.  If only one test has failed or errored, the test will automatically be run again, opening a debugger to show the failure or error.* The AutoTest Notifier (Linux only for now): The AutoTest Notifier does not show a window on the screen.  Rather, it integrates with your desktop environment's notification system to display a pop-up notification whenever a test run is complete.  The position, appearance, and duration of the notification can be configured using your desktop environment's settings.  To enable the AutoTest Notifier, select `Tools` -> `AutoTest Notifier` in the Launcher.If you desire, you can run both AutoTest UI's at the same time.  To disable AutoTest, simply close the AutoTest UI and disable the AutoTest Notifier.  AutoTest will then be inactive until a UI is opened again.# Limitations* SUnitToo(ls)-AutoTest does not run tests when class definitions are changed.  Class change notifications are triggered at some inopportune times (such as when loading code from Store), and so I removed the code that triggers test runs on class definition changes.* SUnitToo(ls)-AutoTest does update the state of the method and class icons when run, but those changes are not immediately visible until some other action causes the browser to redisplay itself.  The browser does not provide a proper API for such a refresh.  There is an API that could be used, but it also causes any in-progress code changes to be lost, which is unacceptable.* AutoTest Notifier is Linux-only at present.  If you are interested in an AutoTest Notifier for another platform, I'd be happy to accept contributions.  I will likely implement something for Mac OS/X when I have time.* It is sometimes not safe to have SUnitToo(ls)-AutoTest active when working on some kinds of code, particularly DLLCC interfaces that are under active development.  Sometimes, running such a test at the wrong time can crash an image.  When working on such code, I recommend closing the AutoTest UI and disabling the AutoTest Notifier to deactivate AutoTest.# Understanding the Code`AutoTest` is the main class.  It is a singleton.  When active, it listens for announcements from a `ChangeSetListener`, asks a `BuildSuite` to create a test suite, and then runs it using `SuiteRunner`.  `SuiteRunner` reports its progress by asking `AutoTestAnnouncer` to announce various progress announcements.  A `MethodHitCounter` (a `MethodWrapper`) is installed for the duration of the test run to report a `HitCount` for the changed method.  An `AutoTestResults` contains the final results of the test run.# AcknowledgementsSUnitToo(ls)-AutoTest was inspired by the [Pharo Autotest](http://www.squeaksource.com/Autotest.html) package by Laurent Laffont.# ContributingI'm happy to receive bug fixes and improvements to this package.  If you'd like to contribute, please publish your changes as a "branch" (non-integer) version in the Public Store Repository and contact me as outlined below to let me know.  I will merge your changes back into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about SUnitToo(ls)-AutoTest and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1492DbUsername: randyDbVersion: 5DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Browser-BaseUI' '') #(#any 'SUnitToo' '') #(#any 'SUnitToo(ls)' '') #(#any 'Method Wrapper Base' ''))PackageName: SUnitToo(ls)-AutoTestParcel: #('SUnitToo(ls)-AutoTest')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Browser-BaseUI' #componentType #package) #(#name 'SUnitToo' #componentType #package) #(#name 'SUnitToo(ls)' #componentType #package) #(#name 'Method Wrapper Base' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Browser-BaseUI' '') #('SUnitToo' '') #('SUnitToo(ls)' '') #('Method Wrapper Base' ''))PrintStringCache: (5,randy)Version: 5Date: 7:57:36 PM April 30, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on April 30, 2013 at 7:57:36 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SUnitToolsAutoTest</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private SUnit.*			private Refactory.Browser.*			</imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></name-space><class><name>TestRunOver</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.TestRunOver</class-id><body>Base class for all normal and abnormal test run announcements.</body></comment><class><name>TestRunCompleted</name><environment>SUnitToolsAutoTest</environment><super>SUnitToolsAutoTest.TestRunOver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.TestRunCompleted</class-id><body>Announced when a test run has completed normally.Instance Variables	results	&lt;AutoTestResults&gt;	The results of running the TestSuite.</body></comment><class><name>AutoTest</name><environment>SUnitToolsAutoTest</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listener suiteRunner announcer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.AutoTest</class-id><body>AutoTest is a singleton that coordinates the various parts of the AutoTest package.It waits for MethodModified announcements from its ChangeSetListener.  When it receives one, it asks BuildSuite to create an appropriate test suite for the changed method, and then asks a SuiteRunner to run it.  Only one test run can be in progress at a time.Instance Variables	announcer    &lt;AutoTestAnnouncer&gt;  The announcer that will report on test run progress.	listener	&lt;ChangeSetListener&gt;	Listens for ChangeSet notifications and announces method changes.	suiteRunner   &lt;SuiteRunner&gt;   The currently active SuiteRunner, if any.</body></comment><class><name>HitCount</name><environment>SUnitToolsAutoTest</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.HitCount</class-id><body>Represents the number of times a method was invoked during a test run.  If nil, then the hit count was not applicable.Instance Variables	count	&lt;ArithmeticValue&gt;	The number of times the method was invoked, or nil if not applicable.</body></comment><class><name>BuildSuite</name><environment>SUnitToolsAutoTest</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigatorState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.BuildSuite</class-id><body>Builds a TestSuite containing tests that are relevant to a recently-changed method.Instance Variables	navigatorState	&lt;NavigatorState&gt;	Represents the changed method.</body></comment><class><name>SuiteRunner</name><environment>SUnitToolsAutoTest</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>announcer cancelRequested process </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.SuiteRunner</class-id><body>Runs a test suite in a background process, announcing progress as it goes along.  Allows the user to cancel the test run if desired.Instance Variables	announcer	&lt;AutoTestAnnouncer&gt;	The announcer to use when announcing progress.	cancelRequested	&lt;Boolean&gt;	True if the user has requested that the test run be canceled.	process	&lt;Process&gt;	The process that is running the tests, or nil if none.</body></comment><class><name>FinishedTest</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.FinishedTest</class-id><body>Announced when an AutoTest has finished running a single TestCase.Instance Variables	testCase	&lt;TestCase&gt;	The TestCase that was finished.</body></comment><class><name>TestRunAborted</name><environment>SUnitToolsAutoTest</environment><super>SUnitToolsAutoTest.TestRunOver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.TestRunAborted</class-id><body>Announced when a test run is aborted due to a test resource error.</body></comment><class><name>SkippingTests</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.SkippingTests</class-id><body>Announced when one or more tests are skipped due to unavailable test resources.Instance Variables	count	&lt;Integer&gt;	The number of tests being skipped.</body></comment><class><name>MethodHitCounter</name><environment>SUnitToolsAutoTest</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>hitCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.MethodHitCounter</class-id><body>A MethodWrapper that counts the number of times the method was invoked before then invoking the original method.Instance Variables	hitCount	&lt;HitCount&gt;	The number of method invocations.</body></comment><class><name>StartingTest</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.StartingTest</class-id><body>Announced when a SuiteRunner is about to run a single TestCase.Instance Variables	testCase	&lt;TestCase&gt;	The TestCase that is about to be run.</body></comment><class><name>ChangeSetListener</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.ChangeSetListener</class-id><body>Listens for ChangeSet notifications, and translates method additions and changes into MethodModified announcements.</body></comment><class><name>TestRunCanceled</name><environment>SUnitToolsAutoTest</environment><super>SUnitToolsAutoTest.TestRunOver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.TestRunCanceled</class-id><body>Announced when a test run is canceled by the user.</body></comment><class><name>Skip</name><environment>SUnitToolsAutoTest</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.Skip</class-id><body>A TestResult representing tests that are skipped due to unavailable test resources.</body></comment><class><name>AutoTestResults</name><environment>SUnitToolsAutoTest</environment><super>SUnit.Results</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hitCounter skips </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.AutoTestResults</class-id><body>The results of a test run.  In addition to the normal test results, it also tracks tests that were skipped due to unavailable test resources and the number of times the most-recently-changed method was executed during the test run.Instance Variables	hitCounter	&lt;MethodHitCounter&gt;	Counts the number of times the most-recently-changed method was executed.	skips	&lt;Collection&gt;	The tests that were skipped due to unavailable test resources.</body></comment><class><name>RunningSuite</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSuite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.RunningSuite</class-id><body>Announced when a SuiteRunner is about to run a TestSuite.Instance Variables	testSuite	&lt;TestSuite&gt;	The TestSuite that is about to be run.</body></comment><class><name>MethodModified</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.MethodModified</class-id><body>Announced when a ChangeSetListener has detected that a method has been added or changed anywhere in the image.Instance Variables	method	&lt;CompiledMethod&gt;	The method that was added or changed.</body></comment><class><name>AutoTestAnnouncer</name><environment>SUnitToolsAutoTest</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>autoTest </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></class><comment><class-id>SUnitToolsAutoTest.AutoTestAnnouncer</class-id><body>Announces test run progress.  Also keeps track of whether or not it has any subscribers, activating or deactivating its owning AutoTest as appropriate.Instance Variables	autoTest	&lt;AutoTest&gt;	The AutoTest that owns this announcer.</body></comment><shared-variable><name>Current</name><environment>SUnitToolsAutoTest.AutoTest</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>SUnitToo(ls)-AutoTest</package></attributes></shared-variable><methods><class-id>SUnitToolsAutoTest.TestRunCompleted</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">results: aResults	results := aResults</body></methods><methods><class-id>SUnitToolsAutoTest.TestRunCompleted</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">results	^results</body></methods><methods><class-id>SUnitToolsAutoTest.TestRunCompleted class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">withResults: aResults	^self new results: aResults</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest</class-id> <category>api</category><body package="SUnitToo(ls)-AutoTest">beActive	listener ifNotNil: [^self].	listener := ChangeSetListener new.	self observeListener.	listener startListening</body><body package="SUnitToo(ls)-AutoTest">beInactive	listener ifNil: [^self].	self releaseListener.	listener stopListening.	listener := nil</body><body package="SUnitToo(ls)-AutoTest">requestCancel	suiteRunner requestCancel</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest</class-id> <category>private</category><body package="SUnitToo(ls)-AutoTest">isSuiteRunnerActive	^suiteRunner notNil and: [suiteRunner isActive]</body><body package="SUnitToo(ls)-AutoTest">noteMethodModified: aMethodModified	| suite method |	self isSuiteRunnerActive ifTrue: [^self].	method := aMethodModified method.	suite := (BuildSuite forModifiedMethod: method) suite.	self runSuite: suite forModifiedMethod: method</body><body package="SUnitToo(ls)-AutoTest">observeListener	listener when: MethodModified send: #noteMethodModified: to: self</body><body package="SUnitToo(ls)-AutoTest">releaseListener	listener unsubscribe: self</body><body package="SUnitToo(ls)-AutoTest">runSuite: aTestSuite forModifiedMethod: aCompiledMethod	suiteRunner := SuiteRunner announcer: announcer.	suiteRunner startRunningSuite: aTestSuite		forModifiedMethod: aCompiledMethod</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initialize	super initialize.	announcer := AutoTestAnnouncer autoTest: self</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">announcer	^announcer</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest class</class-id> <category>utility</category><body package="SUnitToo(ls)-AutoTest">reset	Current ifNotNil: [Current beInactive].	Current := nil</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTest class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">current	^Current ifNil: [Current := self new]</body><body package="SUnitToo(ls)-AutoTest">new	^super new initialize</body></methods><methods><class-id>SUnitToolsAutoTest.HitCount</class-id> <category>hits</category><body package="SUnitToo(ls)-AutoTest">recordHit	count ifNil: [^self].	count := count + 1</body><body package="SUnitToo(ls)-AutoTest">startCounting	count := 0</body></methods><methods><class-id>SUnitToolsAutoTest.HitCount</class-id> <category>testing</category><body package="SUnitToo(ls)-AutoTest">isApplicable	^count notNil</body><body package="SUnitToo(ls)-AutoTest">isOK	^self isApplicable not or: [count &gt; 0]</body></methods><methods><class-id>SUnitToolsAutoTest.HitCount</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">count	^count</body></methods><methods><class-id>SUnitToolsAutoTest.BuildSuite</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">suite	| suite |	suite := TestSuite new.	navigatorState		currentTestClassAndSelectorsDo: [:mclass :selector | suite addTest: (mclass selector: selector)].	^suite</body></methods><methods><class-id>SUnitToolsAutoTest.BuildSuite</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initializeMethod: aCompiledMethod	navigatorState := (NavigatorState new)				classOrNameSpace: aCompiledMethod mclass;				selector: aCompiledMethod selector;				yourself</body></methods><methods><class-id>SUnitToolsAutoTest.BuildSuite class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">forModifiedMethod: aCompiledMethod	^self new initializeMethod: aCompiledMethod</body></methods><methods><class-id>SUnitToolsAutoTest.SuiteRunner</class-id> <category>private</category><body package="SUnitToo(ls)-AutoTest">forceCancel	process terminate.	process := nil.	self testRunCanceled</body><body package="SUnitToo(ls)-AutoTest">isActive	^process notNil</body><body package="SUnitToo(ls)-AutoTest">noteUnavailableResources: aResourceSet forSuite: aTestSuite	| skippedTests |	skippedTests := aTestSuite definitionsForResources: aResourceSet.	skippedTests do: [:each | TestCase announce: (Skip definition: each)].	self testsSkipped: skippedTests size</body><body package="SUnitToo(ls)-AutoTest">runSuite: aTestSuite	^[aTestSuite runUsing: [:each | self runTest: each]]		on: TestResourceUnavailable		do: 			[:ex |			self noteUnavailableResources: ex parameter forSuite: aTestSuite.			ex resume]</body><body package="SUnitToo(ls)-AutoTest">runSuite: aTestSuite forModifiedMethod: aCompiledMethod	| results |	cancelRequested := false.	results := AutoTestResults forModifiedMethod: aCompiledMethod.	self testRunStarted: aTestSuite.		[	[results collectWhile: [self runSuite: aTestSuite].	self testRunOver: results]			on: TestResourceError			do: [:ex | ^self testRunAborted]]			ifCurtailed: [self testRunCanceled]</body><body package="SUnitToo(ls)-AutoTest">runTest: aTestCase	"A test case might have been deleted after building the test suite, as part of the same 	refactoring that kicked off this test run, so guard against running it."	cancelRequested ifTrue: [^self].	aTestCase asDefinition ifNil: [^self].	self testStarted: aTestCase.	aTestCase run.	self testFinished: aTestCase</body></methods><methods><class-id>SUnitToolsAutoTest.SuiteRunner</class-id> <category>private - announcing</category><body package="SUnitToo(ls)-AutoTest">testFinished: aTestCase	announcer announce: (FinishedTest testCase: aTestCase)</body><body package="SUnitToo(ls)-AutoTest">testRunAborted	announcer announce: TestRunAborted new</body><body package="SUnitToo(ls)-AutoTest">testRunCanceled	announcer announce: TestRunCanceled new</body><body package="SUnitToo(ls)-AutoTest">testRunCompleted: aTestResults	"Would like to #refreshLists here to update test status, but this causes RB windows to throw away any pending method changes.	This is especially bad if a test run was kicked off by the interactive compiler error handler, and it hasn't finished doing its job yet."	"BrowserNavigator allGeneralInstancesDo: #refreshLists."	announcer announce: (TestRunCompleted withResults: aTestResults)</body><body package="SUnitToo(ls)-AutoTest">testRunOver: anAutoTestResults	cancelRequested		ifTrue: [self testRunCanceled]		ifFalse: [self testRunCompleted: anAutoTestResults]</body><body package="SUnitToo(ls)-AutoTest">testRunStarted: aTestSuite	announcer announce: (RunningSuite suite: aTestSuite)</body><body package="SUnitToo(ls)-AutoTest">testStarted: aTestCase	announcer announce: (StartingTest testCase: aTestCase)</body><body package="SUnitToo(ls)-AutoTest">testsSkipped: anInteger	announcer announce: (SkippingTests count: anInteger)</body></methods><methods><class-id>SUnitToolsAutoTest.SuiteRunner</class-id> <category>running</category><body package="SUnitToo(ls)-AutoTest">requestCancel	cancelRequested := true.	1 seconds toFinish: [[self isActive] whileTrue: [10 milliseconds wait]]		orElse: [self forceCancel]</body><body package="SUnitToo(ls)-AutoTest">startRunningSuite: aTestSuite forModifiedMethod: aCompiledMethod	Processor activeProcess isUnderDebug ifTrue: [^self].	process := 			[[self runSuite: aTestSuite forModifiedMethod: aCompiledMethod]				ensure: [process := nil]]					forkAt: Processor userBackgroundPriority.	process name: 'AutoTest SuiteRunner'</body></methods><methods><class-id>SUnitToolsAutoTest.SuiteRunner</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initializeAnnouncer: anAnnouncer	announcer := anAnnouncer</body></methods><methods><class-id>SUnitToolsAutoTest.SuiteRunner class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">announcer: anAnnouncer	^self new initializeAnnouncer: anAnnouncer</body></methods><methods><class-id>SUnitToolsAutoTest.FinishedTest</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">testCase: aTestCase	testCase := aTestCase</body></methods><methods><class-id>SUnitToolsAutoTest.FinishedTest</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">testCase	^testCase</body></methods><methods><class-id>SUnitToolsAutoTest.FinishedTest class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">testCase: aTestCase	^self new testCase: aTestCase</body></methods><methods><class-id>SUnitToolsAutoTest.SkippingTests</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initializeCount: anInteger	count := anInteger</body></methods><methods><class-id>SUnitToolsAutoTest.SkippingTests</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">count	^count</body></methods><methods><class-id>SUnitToolsAutoTest.SkippingTests class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">count: anInteger	^self new initializeCount: anInteger</body></methods><methods><class-id>SUnitToolsAutoTest.MethodHitCounter</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">hitCount	^hitCount</body></methods><methods><class-id>SUnitToolsAutoTest.MethodHitCounter</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">class: aClass selector: aSelector	hitCount := HitCount new.	hitCount startCounting.	^super class: aClass selector: aSelector</body></methods><methods><class-id>SUnitToolsAutoTest.MethodHitCounter</class-id> <category>evaluating</category><body package="SUnitToo(ls)-AutoTest">valueWithReceiver: anObject arguments: anArrayOfObjects	hitCount recordHit.	^clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects</body></methods><methods><class-id>SUnitToolsAutoTest.StartingTest</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">testCase: aTestCase	testCase := aTestCase</body></methods><methods><class-id>SUnitToolsAutoTest.StartingTest</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">testCase	^testCase</body></methods><methods><class-id>SUnitToolsAutoTest.StartingTest class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">testCase: aTestCase	^self new testCase: aTestCase</body></methods><methods><class-id>SUnitToolsAutoTest.ChangeSetListener</class-id> <category>updating</category><body package="SUnitToo(ls)-AutoTest">addSelector: aSelector class: aClass attributes: ignored	self methodModified: aSelector class: aClass</body><body package="SUnitToo(ls)-AutoTest">changeSelector: aSelector class: aClass attributes: ignored	self methodModified: aSelector class: aClass</body><body package="SUnitToo(ls)-AutoTest">update: aSymbol with: aParameter from: anObject	^(anObject == ChangeSet and: [self respondsTo: aSymbol])		ifTrue: [self perform: aSymbol withArguments: aParameter]		ifFalse: [super update: aSymbol with: aParameter from: anObject]</body></methods><methods><class-id>SUnitToolsAutoTest.ChangeSetListener</class-id> <category>private</category><body package="SUnitToo(ls)-AutoTest">methodModified: aSelector class: aClass	| method |	method := aClass compiledMethodAt: aSelector ifAbsent: [^self].	self announce: (MethodModified method: method)</body></methods><methods><class-id>SUnitToolsAutoTest.ChangeSetListener</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">startListening	(ChangeSet dependents includes: self) ifTrue: [^self].	ChangeSet addDependent: self</body><body package="SUnitToo(ls)-AutoTest">stopListening	ChangeSet removeDependent: self</body></methods><methods><class-id>SUnitToolsAutoTest.Skip</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">addTo: aResults	(aResults respondsTo: #addSkip:) ifFalse: [^self].	aResults addSkip: self</body></methods><methods><class-id>SUnitToolsAutoTest.Skip class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">definition: aMethodDefinition	^self new definition: aMethodDefinition</body></methods><methods><class-id>SUnitToolsAutoTest.Skip class</class-id> <category>utility</category><body package="SUnitToo(ls)-AutoTest">testCaseIcon	^TestIcons caseNotRun</body><body package="SUnitToo(ls)-AutoTest">testMethodIcon	^TestIcons testNotRun</body><body package="SUnitToo(ls)-AutoTest">testWorseThan: aResultType	^aResultType ~~ Failure and: [aResultType ~~ SomeError]</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestResults</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">addSkip: aSkip	skips add: aSkip</body><body package="SUnitToo(ls)-AutoTest">cease	hitCounter uninstall.	super cease</body><body package="SUnitToo(ls)-AutoTest">collect	super collect.	hitCounter install</body><body package="SUnitToo(ls)-AutoTest">hitCount	^hitCounter hitCount</body><body package="SUnitToo(ls)-AutoTest">ranCount	^super ranCount + self skippedCount</body><body package="SUnitToo(ls)-AutoTest">skippedCount	^skips size</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestResults</class-id> <category>printing</category><body package="SUnitToo(ls)-AutoTest">countSelectors	^super countSelectors copyWith: #skippedCount</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestResults</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initializeModifiedMethod: aCompiledMethod	hitCounter := MethodHitCounter on: aCompiledMethod selector				inClass: aCompiledMethod mclass.	skips := Set new</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestResults</class-id> <category>testing</category><body package="SUnitToo(ls)-AutoTest">isEmpty	^super isEmpty and: [skips isEmpty]</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestResults class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">forModifiedMethod: aCompiledMethod	^self new initializeModifiedMethod: aCompiledMethod</body></methods><methods><class-id>SUnitToolsAutoTest.RunningSuite</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">testSuite: aTestSuite	testSuite := aTestSuite</body></methods><methods><class-id>SUnitToolsAutoTest.RunningSuite</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">testSuite	^testSuite</body></methods><methods><class-id>SUnitToolsAutoTest.RunningSuite class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">suite: aTestSuite	^self new testSuite: aTestSuite</body></methods><methods><class-id>SUnitToolsAutoTest.MethodModified</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">method: aCompiledMethod	method := aCompiledMethod</body></methods><methods><class-id>SUnitToolsAutoTest.MethodModified</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">method	^method</body></methods><methods><class-id>SUnitToolsAutoTest.MethodModified class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">method: aCompiledMethod	^self new method: aCompiledMethod</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestAnnouncer</class-id> <category>announcements-configuring</category><body package="SUnitToo(ls)-AutoTest">unsubscribe: anObject	super unsubscribe: anObject.	self updateActiveState</body><body package="SUnitToo(ls)-AutoTest">unsubscribe: anObject from: announcementClassOrSet	super unsubscribe: anObject from: announcementClassOrSet.	self updateActiveState</body><body package="SUnitToo(ls)-AutoTest">when: announcementClassOrSet do: aBlock for: anObject	super when: announcementClassOrSet do: aBlock for: anObject.	self updateActiveState</body><body package="SUnitToo(ls)-AutoTest">when: anAnnouncementOrSymbol send: aSelectorSymbol to: anObject	super when: anAnnouncementOrSymbol send: aSelectorSymbol to: anObject.	self updateActiveState</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestAnnouncer</class-id> <category>private</category><body package="SUnitToo(ls)-AutoTest">hasSubscriptions	^self subscriptionRegistryOrNil ifNil: [false] ifNotNil: #notEmpty</body><body package="SUnitToo(ls)-AutoTest">updateActiveState	self hasSubscriptions		ifTrue: [autoTest beActive]		ifFalse: [autoTest beInactive]</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestAnnouncer</class-id> <category>initialize-release</category><body package="SUnitToo(ls)-AutoTest">initializeAutoTest: anAutoTest	autoTest := anAutoTest</body></methods><methods><class-id>SUnitToolsAutoTest.AutoTestAnnouncer class</class-id> <category>instance creation</category><body package="SUnitToo(ls)-AutoTest">autoTest: anAutoTest	^self new initializeAutoTest: anAutoTest</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">method	^definition method unwrappedMethod</body></methods><methods><class-id>SUnit.Result</class-id> <category>accessing</category><body package="SUnitToo(ls)-AutoTest">method	"Need the override because SUnitToo has a duplicate subclass implementation of it.  We just call super here, because that's what we want.	The #yourself send at the end is there to fool CodeCritic."	^super method yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>TestCaseAnnouncement</name><environment>SUnit</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class></st-source>